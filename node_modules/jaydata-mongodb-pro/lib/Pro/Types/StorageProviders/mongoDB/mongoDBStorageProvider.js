$C('$data.modelBinder.mongoDBProModelBinderConfigCompiler', $data.modelBinder.ModelBinderConfigCompiler, null, {
    _addPropertyToModelBinderConfig: function (elementType, builder) {
        var storageModel = this._query.context._storageModel.getStorageModel(elementType);
        if (elementType.memberDefinitions) {
            elementType.memberDefinitions.getPublicMappedProperties().forEach(function (prop) {
                if ((!storageModel) || (storageModel && !storageModel.Associations[prop.name] && !storageModel.ComplexTypes[prop.name])) {

                    if (!storageModel && this._query.context.storageProvider.supportedDataTypes.indexOf(Container.resolveType(prop.dataType)) < 0) {
                        //complex type
                        builder.selectModelBinderProperty(prop.name);
                        builder.modelBinderConfig['$type'] = Container.resolveType(prop.dataType);
                        
                        if (this._isoDataProvider) {
                            builder.modelBinderConfig['$selector'] = ['json:' + prop.name + '.results', 'json:' + prop.name];
                        } else {
                            builder.modelBinderConfig['$selector'] = 'json:' + prop.name;
                        }
                        this._addPropertyToModelBinderConfig(Container.resolveType(prop.dataType), builder);
                        builder.popModelBinderProperty();
                    } else {
                        if (prop.key) {
                            builder.addKeyField(prop.computed ? '_id' : prop.name);
                        }
                        if (prop.concurrencyMode === $data.ConcurrencyMode.Fixed) {
                            builder.modelBinderConfig[prop.name] = { $selector: 'json:__metadata', $source: 'etag' }
                        } else {
                            var dt = Container.resolveType(prop.dataType);
                            if (dt === $data.Array || dt === $data.Object){
                                builder.modelBinderConfig[prop.name] = {
                                    $type: dt,
                                    $source: prop.name
                                };
                            }else builder.modelBinderConfig[prop.name] = prop.computed ? '_id' : prop.name;
                        }
                    }
                }
            }, this);
        } else {
            builder._binderConfig.$item = builder._binderConfig.$item || {};
            builder.modelBinderConfig = builder._binderConfig.$item;
        }
        if (storageModel) {
            this._addComplexTypeProperties(storageModel.ComplexTypes, builder);
        }
    },
    _addComplexType: function(ct, builder){
        if (ct.ToType !== $data.Array){
            builder.modelBinderConfig['$type'] = ct.ToType;
            if (this._isoDataProvider) {
                builder.modelBinderConfig['$selector'] = ['json:' + ct.FromPropertyName + '.results', 'json:' + ct.FromPropertyName];
            } else {
                builder.modelBinderConfig['$selector'] = 'json:' + ct.FromPropertyName;
            }
            this._addPropertyToModelBinderConfig(ct.ToType, builder);
        }else{
            var dt = ct.ToType;
            var et = Container.resolveType(ct.FromType.memberDefinitions.getMember(ct.FromPropertyName).elementType);
            if (dt === $data.Array && et && et.isAssignableTo && et.isAssignableTo($data.Entity)){
                config = {
                    $type: $data.Array,
                    $selector: 'json:' + ct.FromPropertyName,
                    $item: {
                        $type: et
                    }
                };
                var md = et.memberDefinitions.getPublicMappedProperties();
                for (var i = 0; i < md.length; i++){
                    config.$item[md[i].name] = { $type: md[i].type, $source: md[i].name };
                }
                $data.typeSystem.extend(builder.modelBinderConfig, config);
                //builder.modelBinderConfig[ct.FromPropertyName] = config;
            }else{
                /*builder.modelBinderConfig[ct.FromPropertyName] = {};
                builder.modelBinderConfig[ct.FromPropertyName].$type = ct.ToType;
                builder.modelBinderConfig[ct.FromPropertyName].$source = ct.FromPropertyName;*/
                if (dt === $data.Array && et === $data.ObjectID){
                    $data.typeSystem.extend(builder.modelBinderConfig, {
                        $type: $data.Array,
                        $selector: 'json:' + ct.FromPropertyName,
                        $item: {
                            $type: $data.ObjectID,
                            $value: function(meta, data){
                                return data;
                                /*var type = Container.resolveName(meta.$type);
                                var converter = this.context.storageProvider.fieldConverter.fromDb;
                                var converterFn = converter ? converter[type] : undefined;
                                
                                return converter && converter[type] ? converter[type](data) : new (Container.resolveType(type))(data);*/
                            }
                        }
                    });
                }else{
                    $data.typeSystem.extend(builder.modelBinderConfig, {
                        $type: ct.ToType,
                        $source: ct.FromPropertyName
                    });
                }
            }
        }
    },
    _addComplexTypeProperties: function (complexTypes, builder) {
        var self = this;
        complexTypes.forEach(function (ct) {
            builder.selectModelBinderProperty(ct.FromPropertyName);
            self._addComplexType(ct, builder);
            builder.popModelBinderProperty();
        }, this);
    },
    VisitComplexTypeExpression: function (expression, builder) {
        this.Visit(expression.source, builder);
        this.Visit(expression.selector, builder);
        
        if (('$selector' in builder.modelBinderConfig) && (builder.modelBinderConfig.$selector.length > 0)) {
            if (builder.modelBinderConfig.$selector instanceof $data.Array) {
                var temp = builder.modelBinderConfig.$selector[1];
                builder.modelBinderConfig.$selector[0] = temp + '.' + expression.selector.memberName + '.results';
                builder.modelBinderConfig.$selector[1] = temp + '.' + expression.selector.memberName;
            } else {
                var type = Container.resolveType(expression.selector.memberDefinition.type);
                var elementType = type === $data.Array && expression.selector.memberDefinition.elementType ? Container.resolveType(expression.selector.memberDefinition.elementType) : type;
                if (elementType.memberDefinitions.getMember(expression.selector.memberName))
                    builder.modelBinderConfig.$selector += '.' + expression.selector.memberName;
            }

        } else {
            //builder.modelBinderConfig['$selector'] = 'json:' + expression.selector.memberName;
            var type = Container.resolveType(expression.selector.memberDefinition.type);
            var elementType = type === $data.Array && expression.selector.memberDefinition.elementType ? Container.resolveType(expression.selector.memberDefinition.elementType) : undefined;
            if (type === $data.Array && elementType && elementType.isAssignableTo && elementType.isAssignableTo($data.Entity)){
                this._addComplexType(expression.selector.memberDefinition.storageModel.ComplexTypes[expression.selector.memberDefinition.name], builder);
            }else{
                //builder.modelBinderConfig.$type = Container.resolveType(expression.selector.memberDefinition.type);
                builder.modelBinderConfig.$source = expression.selector.memberName;
                
                if (type !== $data.Array){// && (type.isAssignableTo ? !type.isAssignableTo($data.Entity) : true)){
                    builder.modelBinderConfig.$selector = 'json:' + expression.selector.memberDefinition.name;
                    //delete builder.modelBinderConfig.$source;
                    //console.log(builder.modelBinderConfig);
                }
                
                if (builder._binderConfig.$item === builder.modelBinderConfig &&
                    expression.selector.memberDefinition.storageModel &&
                    expression.selector.memberDefinition.storageModel.ComplexTypes[expression.selector.memberDefinition.name]){
                    builder.modelBinderConfig.$selectorMemberInfo = builder.modelBinderConfig.$selector;
                    delete builder.modelBinderConfig.$selector;
                }else{
                    delete builder.modelBinderConfig.$source;
                }
            }
        }
    },
    VisitMemberInfoExpression: function (expression, builder) {
        var type = Container.resolveType(expression.memberDefinition.type);
        var elementType = type === $data.Array && expression.memberDefinition.elementType ? Container.resolveType(expression.memberDefinition.elementType) : undefined;
        builder.modelBinderConfig['$type'] = type;
        
        if (type === $data.Array && elementType && elementType.isAssignableTo && elementType.isAssignableTo($data.Entity)){
            this._addComplexType(expression.memberDefinition.storageModel.ComplexTypes[expression.memberName], builder);
        }else{
            if (expression.memberDefinition.storageModel && expression.memberName in expression.memberDefinition.storageModel.ComplexTypes) {
                this._addPropertyToModelBinderConfig(Container.resolveType(expression.memberDefinition.type), builder);
            } else {
                if (builder._binderConfig.$item === builder.modelBinderConfig){
                    builder._binderConfig.$item = {
                        $type: builder.modelBinderConfig.$type,
                        $selector: builder.modelBinderConfig.$selectorMemberInfo || builder.modelBinderConfig.$selector,
                        $source: expression.memberDefinition.computed ? '_id' : expression.memberName
                    };
                }else{
                    builder.modelBinderConfig['$source'] = expression.memberDefinition.computed ? '_id' : expression.memberName;
                }
            }
        }
    }
});

$C('$data.storageProviders.mongoDBPro.mongoDBProjectionCompiler', $data.Expressions.EntityExpressionVisitor, null, {
    constructor: function (provider, lambdaPrefix, compiler) {
        this.provider = provider;
        this.lambdaPrefix = lambdaPrefix;
        if (compiler){
            this.compiler = compiler;
            this.includes = compiler.includes;
            this.mainEntitySet = compiler.mainEntitySet;
        }
    },

    compile: function (expression, context) {
        //console.log(JSON.stringify(expression, null, '    '));
        this.Visit(expression, context);
        delete context.current;
        delete context.complexType;
    },
    VisitProjectionExpression: function (expression, context) {
        this.Visit(expression.selector, context);
    },
    VisitParametricQueryExpression: function (expression, context) {
        this.Visit(expression.expression, context);
    },
    VisitObjectLiteralExpression: function (expression, context) {
        var tempObjectLiteralPath = this.ObjectLiteralPath;
        this.hasObjectLiteral = true;
        expression.members.forEach(function (member, index) {
            this.Visit(member, context);
        }, this);
    },
    VisitObjectFieldExpression: function (expression, context) {
        this.Visit(expression.expression, context);
    },

    VisitComplexTypeExpression: function (expression, context) {
        this.Visit(expression.source, context);
        this.Visit(expression.selector, context);
        //context.complexType = context.current;
    },
    
    VisitEntityFieldExpression: function (expression, context) {
        this.Visit(expression.source, context);
        this.Visit(expression.selector, context);
    },
    VisitEntityExpression: function (expression, context) {
        if (context.includeOptions && !context.includeOptions.fields){
            //console.log('no fields on include', context.include.name);
            context.include.full = true;
        }
        delete context.include;
        delete context.includeOptions;
        this.Visit(expression.source, context);
    },
    VisitEntitySetExpression: function (expression, context) {
        if (expression.source instanceof $data.Expressions.EntityExpression) {
            this.Visit(expression.source, context);
        }
        if (expression.selector instanceof $data.Expressions.AssociationInfoExpression) {
            this.Visit(expression.selector, context);
        }
    },
    VisitAssociationInfoExpression: function (expression, context) {
        this.includes = this.includes || [];
        var from = context.include ? context.include.name + '.' + expression.associationInfo.FromPropertyName : expression.associationInfo.FromPropertyName;
        var includeFragment = from.split('.');
        var tempData = null;
        var storageModel = this.mainEntitySet.entityContext._storageModel.getStorageModel(this.mainEntitySet.createNew);
        for (var i = 0; i < includeFragment.length; i++) {
            if (tempData) { tempData += '.' + includeFragment[i]; } else { tempData = includeFragment[i]; }
            var association = storageModel.Associations[includeFragment[i]];
            if (association) {
                var inc = this.includes.filter(function (include) { return include.name == tempData }, this);
                if (context.include && i < includeFragment.length - 1){
                    if (!context.include.options.fields) context.include.options.fields = { _id: 1 };
                    context.include.options.fields[includeFragment[i + 1]] = 1;
                }
                if (inc.length) {
                    context.includeOptions = inc[0].options;
                    context.include = inc[0];
                    inc[0].mapped = true;
                }else{
                    var inc = { name: tempData, type: association.ToType, from: association.FromType, query: {}, options: {}, mapped: true };
                    context.includeOptions = inc.options;
                    context.include = inc;
                    context.include.options.fields = { _id: 1 };
                    context.include.options.fields[association.ToPropertyName] = 1;
                    /*association.ReferentialConstraint.forEach(function(ref){
                        for (var p in ref){
                            //console.log(ref, p, ref[p]);
                            context.include.options.fields[ref[p]] = 1;
                        }
                    });*/
                    //console.log('association', association.ToPropertyName, association.FromPropertyName, association.To, association.From);
                    this.includes.push(inc);
                }
                if (!context.options.fields) context.options.fields = { _id: 1 };
                context.options.fields[includeFragment[0]] = 1;
                association.ReferentialConstraint.forEach(function(ref){
                    for (var p in ref){
                        //console.log(ref, p, ref[p]);
                        context.options.fields[ref[p]] = 1;
                    }
                });
            }
            else {
                Guard.raise(new Exception("The given include path is invalid: " + expression.associationInfo.FromPropertyName + ", invalid point: " + tempData));
            }
            storageModel = this.mainEntitySet.entityContext._storageModel.getStorageModel(association.ToType);
        }
    },
    VisitMemberInfoExpression: function (expression, context) {
        if (!(context.includeOptions || context.options).fields) (context.includeOptions || context.options).fields = { _id: 1 };
        context.current = expression.memberName;
        if (context.complexType){
            delete (context.includeOptions || context.options).fields[context.complexType];
            //if (typeof context.options.fields[context.complexType] !== 'object') context.options.fields[context.complexType] = {};
            (context.includeOptions || context.options).fields[context.complexType + '.' + context.current] = 1;
            delete context.complexType;
        }else{
            if (!(context.includeOptions || context.options).fields[expression.memberName]) (context.includeOptions || context.options).fields[expression.memberName] = 1;
        }
        delete context.includeOptions;
        delete context.include;
    },
    VisitConstantExpression: function (expression, context) {
    }
});

$C('$data.storageProviders.mongoDBPro.mongoDBWhereCompiler', $data.Expressions.EntityExpressionVisitor, null, {
    constructor: function (provider, lambdaPrefix, compiler) {
        this.provider = provider;
        this.lambdaPrefix = lambdaPrefix;
        if (compiler){
            this.compiler = compiler;
            this.includes = compiler.includes;
            this.mainEntitySet = compiler.mainEntitySet;
        }
    },

    compile: function (expression, context) {
        if (!context.cursor) {
            context.query = {};
            context.cursor = context.query;
        }
        this.Visit(expression, context);
        if (context.query.$and){
            var and = context.query.$and;
            var query = {};
            var valid = true;
            for (var i = 0; i < and.length; i++){
                var a = and[i];
                for (var p in a){
                    if (query[p]){
                        valid = false;
                        break;
                    }
                    query[p] = a[p];
                }
                if (!valid) break;
            }
            if (valid) context.query = query;
        }
        if (this.compiler){
            this.compiler.includes = this.includes;
        }
    },

    VisitParametricQueryExpression: function (expression, context) {
        this.Visit(expression.expression, context);
        if (expression.expression && expression.expression.nodeType === $data.Expressions.ExpressionType.Constant){
            context.value = expression.expression.value;
            context.queryField = context.field = $data.Guid.NewGuid();
            if (context.value === true) context.value = null;
            
            if (context.cursor instanceof Array){
                var o = {};
                o[context.queryField] = context.value;
                context.cursor.push(o);
            }else context.cursor[context.queryField] = context.value;
        }
    },

    VisitUnaryExpression: function (expression, context) {
        context.unary = expression.nodeType;
        this.Visit(expression.operand, context);
    },
    
    _constExpressionFilter: function(expression, context){
        if (expression.left && expression.left.nodeType === $data.Expressions.ExpressionType.Constant && expression.right && [$data.Expressions.ExpressionType.Or, $data.Expressions.ExpressionType.And].indexOf(expression.nodeType) >= 0){
            context.value = expression.left.value;
            context.queryField = context.field = $data.Guid.NewGuid();
            if (context.value === true) context.value = null;
            
            if (context.cursor instanceof Array){
                var o = {};
                o[context.queryField] = context.value;
                context.cursor.push(o);
            }else context.cursor[context.queryField] = context.value;
        }
    },

    VisitSimpleBinaryExpression: function (expression, context) {
     
        var cursor = context.cursor;
        
        switch (expression.nodeType){
            case $data.Expressions.ExpressionType.Or:
                var orCursor = context.cursor;
                
                if (context.cursor instanceof Array){
                    var or = context.unary === $data.Expressions.ExpressionType.Not ? { $nor: [] } : { $or: [] };
                    context.cursor.push(or);
                    context.cursor = or[context.unary === $data.Expressions.ExpressionType.Not ? '$nor' : '$or'];
                }else{
                    context.cursor[context.unary === $data.Expressions.ExpressionType.Not ? '$nor' : '$or'] = [];
                    context.cursor = context.cursor[context.unary === $data.Expressions.ExpressionType.Not ? '$nor' : '$or'];
                }
                if (context.unary === $data.Expressions.ExpressionType.Not) context.unary = undefined;
                this.Visit(expression.left, context);
                this.Visit(expression.right, context);
                this._constExpressionFilter(expression, context);
                
                if (orCursor instanceof Array){
                    for (var i = 0; i < orCursor.length; i++){
                        var o = orCursor[i];
                        if (o.$or){
                            if (o.$or.length == 0){
                                delete o.$or;
                            }else if (o.$or.length == 1){
                                $data.typeSystem.extend(o, o.$or[0]);
                                delete o.$or;
                            }
                        }
                    }
                }else if (orCursor.$or){
                    if (orCursor.$or.length == 0){
                        delete orCursor.$or;
                    }else if (orCursor.$or.length == 1){
                        $data.typeSystem.extend(orCursor, orCursor.$or[0]);
                        delete orCursor.$or;
                    }
                }
                context.cursor = orCursor;
                break;
            case $data.Expressions.ExpressionType.And:
                var andCursor = context.cursor;
                
                if (context.cursor instanceof Array){
                    var and = { $and: [] };
                    context.cursor.push(and);
                    context.cursor = and.$and;
                }else{
                    context.cursor.$and = [];
                    context.cursor = context.cursor.$and;
                }
                this.Visit(expression.left, context);
                this.Visit(expression.right, context);
                this._constExpressionFilter(expression, context);
                
                if (andCursor instanceof Array){
                    for (var i = 0; i < andCursor.length; i++){
                        var a = andCursor[i];
                        if (a.$and){
                            if (a.$and.length == 0){
                                delete a.$and;
                            }else if (a.$and.length == 1){
                                $data.typeSystem.extend(a, a.$and[0]);
                                delete a.$and;
                            }
                        }
                    }
                }else if (andCursor.$and){
                    if (andCursor.$and.length == 0){
                        delete andCursor.$and;
                    }else if (andCursor.$and.length == 1){
                        $data.typeSystem.extend(andCursor, andCursor.$and[0]);
                        delete andCursor.$and;
                    }
                }
                context.cursor = andCursor;
                break;
            case $data.Expressions.ExpressionType.Equal:
            case $data.Expressions.ExpressionType.EqualTyped:
                this.Visit(expression.left, context);
                this.Visit(expression.right, context);
                context.queryField = context.field;
                if (!context.complexType && context.entityType && context.entityType.memberDefinitions.getMember(context.field).computed){
                    delete context.query[context.field];
                    context.queryField = '_id';
                }
                var v = context.value;
                if (context.entityType && context.entityType.memberDefinitions)
                    v = this.provider.fieldConverter.toDb[Container.resolveName(Container.resolveType(context.entityType.memberDefinitions.getMember(context.complexType ? context.lastField : context.field).type))](v);
                else if (context.valueType)
                    v = this.provider.fieldConverter.toDb[Container.resolveName(Container.resolveType(context.valueType))](v);
                context.value = v;
                if (context.cursor instanceof Array){
                    var o = {};
                    o[context.queryField] = context.unary === $data.Expressions.ExpressionType.Not ? { $ne: context.value } : context.value;
                    context.cursor.push(o);
                }else context.cursor[context.queryField] = context.unary === $data.Expressions.ExpressionType.Not ? { $ne: context.value } : context.value;;
                //if (context.include){
                    if (context.options.fields) //context.options.fields = { _id: 1 };
                        context.options.fields[context.queryField] = 1;
                //}
                if (context.unary === $data.Expressions.ExpressionType.Not) context.unary = undefined;
                break;
            case $data.Expressions.ExpressionType.In:
                this.Visit(expression.left, context);
                this.Visit(expression.right, context);
                context.queryField = context.field;
                if (!context.complexType && context.entityType && context.entityType.memberDefinitions.getMember(context.field).computed){
                    delete context.query[context.field];
                    context.queryField = '_id';
                }
                var v = context.value;
                if (v instanceof Array){
                    v = v.map(function (it) { return it.value; });
                    for (var i = 0; i < v.length; i++){
                        if (context.entityType && context.entityType.memberDefinitions)
                            v[i] = this.provider.fieldConverter.toDb[Container.resolveName(Container.resolveType(context.entityType.memberDefinitions.getMember(context.complexType ? context.lastField : context.field).type))](v[i]);
                        else if (context.valueType)
                            v[i] = this.provider.fieldConverter.toDb[Container.resolveName(Container.resolveType(context.valueType))](v[i]);
                    }
                }
                context.value = v;
                if (context.cursor instanceof Array){
                    var o = {};
                    o[context.queryField] = {};
                    if (context.entityType && context.entityType === $data.Array){
                        o[context.queryField] = context.unary === $data.Expressions.ExpressionType.Not ? { $not: context.value } : context.value;
                    }else{
                        o[context.queryField][context.unary === $data.Expressions.ExpressionType.Not ? '$nin' : expression.resolution.mapTo] = context.value;
                    }
                    context.cursor.push(o);
                }else{
                    context.cursor[context.queryField] = {};
                    if (context.entityType && context.entityType === $data.Array){
                        context.cursor[context.queryField] = context.unary === $data.Expressions.ExpressionType.Not ? { $not: context.value } : context.value;
                    }else{
                        context.cursor[context.queryField][context.unary === $data.Expressions.ExpressionType.Not ? '$nin' : expression.resolution.mapTo] = context.value;
                    }
                    //context.cursor[context.queryField][context.unary === $data.Expressions.ExpressionType.Not ? '$nin' : expression.resolution.mapTo] = context.value;
                }
                if (context.options.fields) //context.options.fields = { _id: 1 };
                    context.options.fields[context.queryField] = 1;
                if (context.unary === $data.Expressions.ExpressionType.Not) context.unary = undefined;
                break;
            default:
                this.Visit(expression.left, context);
                this.Visit(expression.right, context);
                context.queryField = context.field;
                if (Array.isArray(context.cursor) && context.cursor[0] && context.cursor[0][context.queryField] && (context.cursor[0][context.queryField].$near || context.cursor[0][context.queryField].$nearSphere || context.cursor[0][context.queryField].$within)){
                    context.query = context.cursor[0];
                    context.cursor = context.cursor[0];
                }
                var c = context.cursor[0] || context.cursor;
                if (c && c[context.queryField] && c[context.queryField].$within){
                    //c[context.queryField].$maxDistance = context.value;
                    break;
                }
                if (!context.complexType && context.entityType && context.entityType.memberDefinitions.getMember(context.field).computed){
                    delete context.query[context.field];
                    context.queryField = '_id';
                }
                var v = context.value;
                if (context.entityType && context.entityType.memberDefinitions)
                    v = this.provider.fieldConverter.toDb[Container.resolveName(Container.resolveType(context.entityType.memberDefinitions.getMember(context.complexType ? context.lastField : context.field).type))](v);
                else if (context.valueType)
                    v = this.provider.fieldConverter.toDb[Container.resolveName(Container.resolveType(context.valueType))](v);
                context.value = v;
                if (context.cursor instanceof Array){
                    var o = {};
                    o[context.queryField] = {};
                    o[context.queryField][expression.resolution.mapTo] = context.value;
                    context.cursor.push(o);
                }else{
                    context.cursor[context.queryField] = {};
                    context.cursor[context.queryField][expression.resolution.mapTo] = context.value;
                }
                //if (!context.include){
                    if (context.options.fields) //context.options.fields = { _id: 1 };
                        context.options.fields[context.queryField] = 1;
                //}
                break;
        }
        
        delete context.complexType;
        delete context.association;
        delete context.field;
        delete context.value;
    },

    VisitEntityFieldExpression: function (expression, context) {
        this.Visit(expression.source, context);
        this.Visit(expression.selector, context);
    },

    VisitAssociationInfoExpression: function (expression, context) {
        this.includes = this.includes || [];
        var from = context.include ? context.include.name + '.' + expression.associationInfo.FromPropertyName : expression.associationInfo.FromPropertyName;
        var includeFragment = from.split('.');
        var tempData = null;
        var storageModel = this.mainEntitySet.entityContext._storageModel.getStorageModel(this.mainEntitySet.createNew);
        for (var i = 0; i < includeFragment.length; i++) {
            if (tempData) { tempData += '.' + includeFragment[i]; } else { tempData = includeFragment[i]; }
            var association = storageModel.Associations[includeFragment[i]];
            if (association) {
                var inc = this.includes.filter(function (include) { return include.name == tempData }, this);
                if (context.include && i < includeFragment.length - 1){
                    if (!context.include.options.fields) context.include.options.fields = { _id: 1 };
                    context.include.options.fields[includeFragment[i + 1]] = 1;
                }
                if (inc.length) {
                    context.includeOptions = inc[0].options;
                    context.include = inc[0];
                }else{
                    var inc = { name: tempData, type: association.ToType, from: association.FromType, query: {}, options: {}, mapped: false };
                    context.includeOptions = inc.options;
                    context.include = inc;
                    context.include.options.fields = { _id: 1 };
                    context.include.options.fields[association.ToPropertyName] = 1;
                    /*association.ReferentialConstraint.forEach(function(ref){
                        for (var p in ref){
                            //console.log(ref, p, ref[p]);
                            context.include.options.fields[ref[p]] = 1;
                        }
                    });*/
                    this.includes.push(inc);
                }
                if (!context.options.fields) context.options.fields = { _id: 1 };
                context.options.fields[includeFragment[0]] = 1;
                association.ReferentialConstraint.forEach(function(ref){
                    for (var p in ref){
                        //console.log(ref, p, ref[p]);
                        context.options.fields[ref[p]] = 1;
                    }
                });
                context.full = true;
                context.mainCursor = context.cursor;
                context.cursor = context.include.query;
                context.entityType = association.ToType;
            }
            else {
                Guard.raise(new Exception("The given include path is invalid: " + expression.associationInfo.FromPropertyName + ", invalid point: " + tempData));
            }
            storageModel = this.mainEntitySet.entityContext._storageModel.getStorageModel(association.ToType);
        }
    },

    VisitMemberInfoExpression: function (expression, context) {
        if ((context.complexType && context.field) /*|| (context.association && context.field)*/){
            context.field = context.field + '.' + expression.memberName;
        }else{
            context.field = expression.memberName;
        }
        if (context.complexType /*|| context.association*/) context.lastField = expression.memberName;
    },
    
    VisitComplexTypeExpression: function(expression, context){
        context.complexType = true;
        this.Visit(expression.source, context);
        this.Visit(expression.selector, context);
        context.entityType = expression.entityType;
    },

    VisitQueryParameterExpression: function (expression, context) {
        context.data += this.provider.fieldConverter.toDb[expression.type](expression.value);
    },

    VisitEntityFieldOperationExpression: function (expression, context) {
        Guard.requireType("expression.operation", expression.operation, $data.Expressions.MemberInfoExpression);
        
        this.Visit(expression.source, context);

        //TODO refactor!
        var opDef = expression.operation.memberDefinition;
        var opName = opDef.mapTo || opDef.name;
        var paramCounter = 0;
        var params = opDef.parameters || [{ name: "@expression" }];

        var args = params.map(function (item, index) {
            if (item.name === "@expression") {
                return expression.source;
            } else {
                return expression.parameters[paramCounter++]
            };
        });

        args.forEach(function (arg, index) {
            this.Visit(arg, context);
        }, this);
        
        var opMapTo;
        var opValue;
        switch (opName){
            case 'contains':
                opMapTo = '$regex';
                opValue = context.value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
                break;
            case 'startsWith':
                opMapTo = '$regex';
                opValue = '^' + context.value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
                break;
            case 'endsWith':
                opMapTo = '$regex';
                opValue = context.value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1") + '$';
                break;
            /*case '$near':
            case '$nearSphere':
                if (context.include){
                    if (!context.include.options.fields) context.include.options.fields = { _id: 1 };
                    context.include.options.fields[context.queryField] = 1;
                }else{
                    if (context.cursor instanceof Array){
                        var o = {};
                        o[context.field] = {};
                        o[context.field][opName] = context.value.coordinates;
                        context.cursor.push(o);
                    }else{
                        context.cursor[context.field] = {};
                        context.cursor[context.field][opName] = context.value.coordinates;
                    }
                }
                return;*/
            case '$center':
            case '$centerSphere':
            case '$polygon':
            case '$polygonSphere':
                var cmd = {};
                cmd[opName] = context.value.coordinates;
                if (context.include){
                    if (!context.include.options.fields) context.include.options.fields = { _id: 1 };
                    context.include.options.fields[context.queryField] = 1;
                }else{
                    if (context.cursor instanceof Array){
                        var o = {};
                        o[context.field] = {};
                        o[context.field].$within = cmd;
                        context.cursor.push(o);
                    }else{
                        context.cursor[context.field] = {};
                        context.cursor[context.field].$within = cmd;
                    }
                }
                return;
            default:
                break;
        }
        
        if (context.unary === $data.Expressions.ExpressionType.Not){
            opValue = '^((?!' + opValue + ').)*$';
        }
        
        if (context.options.fields) //context.options.fields = { _id: 1 };
            context.options.fields[context.field] = 1;
        
        if (!context.include && opMapTo && opValue){
            if (context.cursor instanceof Array){
                var o = {};
                o[context.field] = {};
                o[context.field][opMapTo] = opValue;
                context.cursor.push(o);
            }else{
                context.cursor[context.field] = {};
                context.cursor[context.field][opMapTo] = opValue;
            }
        }
    },

    VisitConstantExpression: function (expression, context) {
        var valueType = Container.resolveName(expression.type); // Container.getTypeName(expression.value);
        context.valueType = valueType;
        context.value = expression.value; //this.provider.fieldConverter.toDb[Container.resolveName(Container.resolveType(valueType))](expression.value);
        var c = Array.isArray(context.cursor) ? context.cursor.filter(function(it){ return typeof it[context.field] !== 'undefined'; })[0] : context.cursor;
        if (c && c[context.field] && c[context.field].$within){
            c = c[context.field];
            if (c.$within.$center){
                c.$within.$center = [c.$within.$center, context.value];
            }else if (c.$within.$centerSphere){
                c.$within.$centerSphere = [c.$within.$centerSphere, context.value];
            }
        }
    },

    VisitEntityExpression: function (expression, context) {
        context.entityType = expression.entityType;
        if (context.mainCursor){
            context.cursor = context.mainCursor;
            delete context.include;
        }
        this.Visit(expression.source, context);
    },

    VisitEntitySetExpression: function (expression, context) {
        this.Visit(expression.source, context);
        if (expression.selector instanceof $data.Expressions.AssociationInfoExpression) {
            this.Visit(expression.selector, context);
            context.data += "/";
        }
    },

    VisitFrameOperationExpression: function (expression, context) {
        this.Visit(expression.source, context);

        Guard.requireType("expression.operation", expression.operation, $data.Expressions.MemberInfoExpression);

        //TODO refactor!
        var opDef = expression.operation.memberDefinition;
        var opName = opDef.mapTo || opDef.name;
        context.data += opName;
        context.data += "(";
        var paramCounter = 0;
        var params = opDef.parameters || [{ name: "@expression" }];

        var args = params.map(function (item, index) {
            if (item.name === "@expression") {
                return expression.source;
            } else {
                return expression.parameters[paramCounter++]
            };
        });

        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            if (arg.value instanceof $data.Queryable) {
                var frameExpression = new opDef.frameType(arg.value.expression);
                var preparator = new $data.Expressions.QueryExpressionCreator(arg.value.entityContext);
                var prep_expression = preparator.Visit(frameExpression);

                var compiler = new $data.storageProviders.mongoDBPro.mongoDBWhereCompiler(this.provider, true);
                var frameContext = { data: "" };
                var compiled = compiler.compile(prep_expression, frameContext);

                context.data += (frameContext.lambda + ': ' + frameContext.data);
            };
        }
        context.data += ")";
    }
});

$C('$data.storageProviders.mongoDBPro.mongoDBOrderCompiler', $data.storageProviders.mongoDBPro.mongoDBWhereCompiler, null, {
    constructor: function (provider, lambdaPrefix, compiler) {
        this.provider = provider;
    },

    compile: function (expression, context) {
        this.Visit(expression, context);
    },
    VisitOrderExpression: function (expression, context) {
        context.data = '';
        this.Visit(expression.selector, context);
        if (!(context.include || context).options.sort) (context.include || context).options.sort = {};
        (context.include || context).options.sort[context.includeSort || context.data] = expression.nodeType == $data.Expressions.ExpressionType.OrderByDescending ? -1 : 1;
        delete context.data;
        delete context.include;
        delete context.includeSort;
        delete context.includeOptions;
    },
    VisitParametricQueryExpression: function (expression, context) {
        this.Visit(expression.expression, context);
    },
    VisitEntityFieldExpression: function (expression, context) {
        this.Visit(expression.source, context);
        this.Visit(expression.selector, context);
    },
    VisitComplexTypeExpression: function (expression, context) {
        this.Visit(expression.source, context);
        if (context.data) context.data += '.';
        //if (context.includeSort) context.includeSort += '.';
        this.Visit(expression.selector, context);
    },
    VisitEntitySetExpression: function (expression, context) {
        if (expression.selector instanceof $data.Expressions.AssociationInfoExpression) {
            this.Visit(expression.source, context);
            this.Visit(expression.selector, context);
        }
    },
    VisitAssociationInfoExpression: function (expression, context) {
        this.includes = this.includes || [];
        var from = context.include ? context.include.name + '.' + expression.associationInfo.FromPropertyName : expression.associationInfo.FromPropertyName;
        var includeFragment = from.split('.');
        var tempData = null;
        var storageModel = this.mainEntitySet.entityContext._storageModel.getStorageModel(this.mainEntitySet.createNew);
        for (var i = 0; i < includeFragment.length; i++) {
            if (tempData) { tempData += '.' + includeFragment[i]; } else { tempData = includeFragment[i]; }
            var association = storageModel.Associations[includeFragment[i]];
            if (association) {
                var inc = this.includes.filter(function (include) { return include.name == tempData }, this);
                if (context.include && i < includeFragment.length - 1){
                    //console.log(context.include.name);
                    if (!context.include.options.sort) context.include.options.sort = {};
                    context.includeSort += includeFragment[i];
                }
                if (inc.length) {
                    context.includeOptions = inc[0].options;
                    context.include = inc[0];
                    context.includeSort = tempData;
                }else{
                    var inc = { name: tempData, type: association.ToType, from: association.FromType, query: {}, options: {}, mapped: false };
                    context.includeOptions = inc.options;
                    context.include = inc;
                    context.includeSort = tempData;
                    this.includes.push(inc);
                }
            }
            else {
                Guard.raise(new Exception("The given include path is invalid: " + expression.associationInfo.FromPropertyName + ", invalid point: " + tempData));
            }
            storageModel = this.mainEntitySet.entityContext._storageModel.getStorageModel(association.ToType);
        }
    },
    VisitEntityExpression: function (expression, context) {
        this.Visit(expression.source, context);
        this.Visit(expression.selector, context);
    },
    VisitMemberInfoExpression: function (expression, context) {
        if (context.includeSort !== undefined){
            if (context.includeSort) context.includeSort += '.';
            context.includeSort += expression.memberDefinition.computed ? '_id' : expression.memberName;
        }else{
            if (context.data) context.data += '.';
            context.data += expression.memberDefinition.computed ? '_id' : expression.memberName;
        }
    },
    
    VisitEntityFieldOperationExpression: function (expression, context) {
        Guard.requireType("expression.operation", expression.operation, $data.Expressions.MemberInfoExpression);
        
        //this.Visit(expression.source, context);

        //TODO refactor!
        var opDef = expression.operation.memberDefinition;
        var opName = opDef.mapTo || opDef.name;
        var paramCounter = 0;
        var params = opDef.parameters || [{ name: "@expression" }];

        var args = params.map(function (item, index) {
            if (item.name === "@expression") {
                return expression.source;
            } else {
                return expression.parameters[paramCounter++]
            };
        });

        args.forEach(function (arg, index) {
            this.Visit(arg, context);
        }, this);
        
        var opMapTo;
        var opValue;
        switch (opName){
            case '$near':
            case '$nearSphere':
                if (context.query[context.data]){
                    context.query[context.data][opName] = context.value.coordinates;
                }else{
                    var cmd = {};
                    cmd[opName] = context.value.coordinates;
                    context.query[context.data] = cmd;
                }
                /*if (context.include){
                    if (!context.include.options.fields) context.include.options.fields = { _id: 1 };
                    context.include.options.fields[context.queryField] = 1;
                }else{
                    if (context.cursor instanceof Array){
                        var o = {};
                        o[context.field] = {};
                        o[context.field].$within = cmd;
                        context.cursor.push(o);
                    }else{
                        context.cursor[context.field] = {};
                        context.cursor[context.field].$within = cmd;
                    }
                }*/
                return;
            default:
                break;
        }
    }
});

$C('$data.storageProviders.mongoDBPro.mongoDBPagingCompiler', $data.Expressions.EntityExpressionVisitor, null, {
    constructor: function (provider) {
        this.provider = provider;
    },

    compile: function (expression, context) {
        this.Visit(expression, context);
    },
    VisitPagingExpression: function (expression, context) {
        var pagingContext = { data: 0 };
        this.Visit(expression.amount, pagingContext);
        switch (expression.nodeType) {
            case $data.Expressions.ExpressionType.Skip: context.options.skip = pagingContext.data; break;
            case $data.Expressions.ExpressionType.Take: context.options.limit = pagingContext.data; break;
            default: Guard.raise("Not supported nodeType"); break;
        }
    },
    VisitConstantExpression: function (expression, context) {
        context.data += expression.value;
    }
});

$C('$data.storageProviders.mongoDBPro.mongoDBFunctionCompiler', $data.Expressions.EntityExpressionVisitor, null, {
    constructor: function (provider) {
        this.provider = provider;
    },
    compile: function (expression, context) {
        //console.log('Visit');
        this.Visit(expression, context);
    },

    VisitParametricQueryExpression: function (expression, context) {
        //console.log('VisitParametricQueryExpression', expression.lambda);
        this.Visit(expression.expression, context);
    },
    VisitUnaryExpression: function (expression, context) {
        //console.log('VisitUnaryExpression', expression.lambda);
        context.data += this.provider.supportedBinaryOperators[expression.resolution.name].mapTo;
        context.data += "(";
        this.Visit(expression.operand, context);
        context.data += ")";
    },
    VisitSimpleBinaryExpression: function (expression, context) {
        //console.log('VisitSimpleBinaryExpression', expression.lambda, expression.resolution);
        if (expression.resolution.reverse) {
            context.data += "(";
            var right = this.Visit(expression.right, context);
            context.data += this.provider.supportedBinaryOperators[expression.resolution.name].mapTo;
            var left = this.Visit(expression.left, context);
            if (expression.resolution.rightValue)
                context.data += expression.resolution.rightValue;
            context.data += ")";
        } else {
            context.data += "(";
            var left = this.Visit(expression.left, context);
            context.data += this.provider.supportedBinaryOperators[expression.resolution.name].mapTo;
            var right = this.Visit(expression.right, context);
            context.data += ")";
        }
    },

    VisitConstantExpression: function (expression, context) {
        //console.log('VisitConstantExpression', expression.lambda);
        var type = Container.resolveType(expression.type);
        var typeName = Container.resolveName(type);
        //console.log(typeName, expression.value);
        context.data += this.provider.fieldConverter.toDb[typeName](expression.value);
    },
    VisitMemberInfoExpression: function (expression, context) {
        //console.log('VisitMemberInfoExpression', expression.lambda, context.data, expression.memberName);
        context.data += expression.memberDefinition.computed ? '_id' : expression.memberName;
    },

    VisitComplexTypeExpression: function (expression, context) {
        //console.log('VisitComplexTypeExpression', expression.lambda, context.data);
        this.Visit(expression.source, context);
        this.Visit(expression.selector, context);
        context.data += ".";
    },

    VisitEntityExpression: function (expression, context) {
        //console.log('VisitEntityExpression', expression.lambda, context.data);
        //console.log('source');
        this.Visit(expression.source, context);
        //console.log('selector');
        //this.Visit(expression.selector, context);
        //context.data += '.';
        context.entityType = expression.entityType;
        if (expression.selector.lambda){
            //console.log('lambda', expression.selector.lambda);
            context.data += expression.selector.lambda + '.';
            context.lambda = expression.selector.lambda;
        }
    },
    VisitEntitySetExpression: function (expression, context) {
        //console.log('VisitEntitySetExpression', expression.lambda, context.data);
        //console.log('source');
        this.Visit(expression.source, context);
        //console.log('selector');
        if (expression.selector instanceof $data.Expressions.AssociationInfoExpression) {
            this.Visit(expression.selector, context);
        }
    },
    VisitObjectLiteralExpression: function (expression, context) {
        //console.log('VisitObjectLiteralExpression', expression.lambda, context.data);
        context.data += '{ ';

        for (var i = 0; i < expression.members.length; i++) {
            var member = expression.members[i];

            if (i > 0)
                context.data += ', ';

            this.Visit(member, context);
        }

        context.data += ' }';
    },
    VisitObjectFieldExpression: function (expression, context) {
        //console.log('VisitObjectFieldExpression', expression.lambda, context.data);
        context.data += expression.fieldName + ': ';
        this.Visit(expression.expression, context);
    },
    VisitAssociationInfoExpression: function(expression, context){
        //console.log('VisitAssociationInfoExpression', expression.lambda, context.data, expression.associationInfo.FromPropertyName)
        context.data += expression.associationInfo.FromPropertyName + '.';
        //console.log(expression);
    },
    VisitEntityFieldOperationExpression: function (expression, context) {
        //console.log('VisitEntityFieldOperationExpression', expression.lambda, context.data);
        Guard.requireType("expression.operation", expression.operation, $data.Expressions.MemberInfoExpression);

        //TODO refactor!
        var opDef = expression.operation.memberDefinition;
        opDef = this.provider.supportedFieldOperations[opDef.name];
        if (opDef.propertyFunction) {
            this.Visit(expression.source, context);
            context.data += '.';
        }

        var opName = opDef.mapTo || opDef.name;
        context.data += opName;
        var paramCounter = 0;
        var params = opDef.parameters || [];

        var args = params.map(function (item, index) {
            if (item.name === "@expression") {
                return expression.source;
            } else {
                return expression.parameters[paramCounter++]
            };
        });

        args.forEach(function (arg, index) {
            if (arg) {
                if (index > 0) {
                    context.data += ",";
                };
                this.Visit(arg, context);
            }
        }, this);
        context.data += opDef.rightValue || "";
    }
});

$C('$data.storageProviders.mongoDBPro.mongoDBCompiler', $data.Expressions.EntityExpressionVisitor, null, {
    constructor: function(){
        this.context = {};
        this.provider = {};
        this.includes = [];
        this.mainEntitySet = null;
    },
    compile: function(query){
        this.provider = query.context.storageProvider;
        this.context = query.context;
        this.mainEntitySet = query.context.getEntitySetFromElementType(query.defaultType);
        this.query = query;

        query.find = {
            query: {},
            options: {}
        };
        
        this.Visit(query.expression, query.find);
        
        query.includes = this.includes;
        //console.log('includes', query.includes);
        
        query.modelBinderConfig = {};
        var modelBinder = new $data.modelBinder.mongoDBProModelBinderConfigCompiler(query, this.includes.filter(function(it){ return it.mapped; }), true);
        modelBinder.Visit(query.expression);
        
        delete query.find.field;
        delete query.find.value;
        delete query.find.data;
        delete query.find.stack;
        delete query.find.or;
        
        return query;
    },
    VisitOrderExpression: function (expression, context) {
        this.Visit(expression.source, context);

        var orderCompiler = new $data.storageProviders.mongoDBPro.mongoDBOrderCompiler(this.provider, null, this);
        orderCompiler.compile(expression, context);
    },
    VisitPagingExpression: function (expression, context) {
        this.Visit(expression.source, context);

        var pagingCompiler = new $data.storageProviders.mongoDBPro.mongoDBPagingCompiler();
        pagingCompiler.compile(expression, context);
    },
    VisitFilterExpression: function (expression, context) {
        this.Visit(expression.source, context);

        var filterCompiler = new $data.storageProviders.mongoDBPro.mongoDBWhereCompiler(this.provider, null, this);
        context.data = "";
        filterCompiler.compile(expression.selector, context);
        //console.log(context.query);
        
        if (this.includes && this.includes.length){
            context.data = "";
            context.lambda = "";
            var funcCompiler = new $data.storageProviders.mongoDBPro.mongoDBFunctionCompiler({
                supportedBinaryOperators: {
                    equal: { mapTo: ' == ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },
                    notEqual: { mapTo: ' != ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },
                    equalTyped: { mapTo: ' === ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },
                    notEqualTyped: { mapTo: ' !== ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },
                    greaterThan: { mapTo: ' > ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },
                    greaterThanOrEqual: { mapTo: ' >= ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },

                    lessThan: { mapTo: ' < ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },
                    lessThenOrEqual: { mapTo: ' <= ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },
                    or: { mapTo: ' || ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },
                    and: { mapTo: ' && ', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.OrderExpression] },

                    "in": { mapTo: ".indexOf(", allowedIn: [$data.Expressions.FilterExpression], rightValue: ') > -1', reverse: true }
                },

                supportedUnaryOperators: {
                    not: { mapTo: '!' }
                },

                supportedFieldOperations: {
                    contains: {
                        mapTo: "$data.StringFunctions.contains(",
                        rightValue: ")",
                        dataType: "boolean",
                        parameters: [{ name: "@expression", dataType: "string" }, { name: "strFragment", dataType: "string" }]
                    },

                    startsWith: {
                        mapTo: "$data.StringFunctions.startsWith(",
                        rightValue: ")",
                        dataType: "boolean",
                        parameters: [{ name: "@expression", dataType: "string" }, { name: "strFragment", dataType: "string" }]
                    },

                    endsWith: {
                        mapTo: "$data.StringFunctions.endsWith(",
                        rightValue: ")",
                        dataType: "boolean",
                        parameters: [{ name: "@expression", dataType: "string" }, { name: "strFragment", dataType: "string" }]
                    }
                },
                
                fieldConverter: {
                    toDb: {
                        '$data.Integer': function (number) { return number; },
                        '$data.Number': function (number) { return number % 1 == 0 ? number : number + 'm'; },
                        '$data.Date': function (date) { return date ? "new Date(Date.parse('" + date.toISOString() + "'))" : null; },
                        '$data.String': function (text) { return "'" + text.replace(/'/g, "''") + "'"; },
                        '$data.Boolean': function (bool) { return bool ? 'true' : 'false'; },
                        '$data.Blob': function (blob) { return typeof blob === 'string' ? "'" + blob.replace(/'/g, "''") + "'" : blob; },
                        '$data.Object': function (o) { return JSON.stringify(o); },
                        '$data.Array': function (o) { return JSON.stringify(o); },
                        '$data.Guid': function (guid) { return "'" + guid.toString() + "'"; }
                    }
                }
            });
            funcCompiler.compile(expression.selector, context);
            context.filter = new Function(context.lambda, 'return ' + context.data + ';');
            context.data = "";
            context.lambda = "";
        }
    },
    VisitProjectionExpression: function (expression, context) {
        this.Visit(expression.source, context);

        var projectionCompiler = new $data.storageProviders.mongoDBPro.mongoDBProjectionCompiler(this.provider, null, this);
        projectionCompiler.compile(expression, context);
    },
    VisitIncludeExpression: function (expression, context) {
        this.Visit(expression.source, context);
        //if (!context['$select']) {
            //if (context['$expand']) { context['$expand'] += ','; } else { context['$expand'] = ''; }
            //context['$expand'] += expression.selector.value.replace(/\./g, '/');

            this.includes = this.includes || [];
            var includeFragment = expression.selector.value.split('.');
            var tempData = null;
            var storageModel = this.mainEntitySet.entityContext._storageModel.getStorageModel(this.mainEntitySet.createNew);
            for (var i = 0; i < includeFragment.length; i++) {
                if (tempData) { tempData += '.' + includeFragment[i]; } else { tempData = includeFragment[i]; }
                var association = storageModel.Associations[includeFragment[i]];
                if (association) {
                    var inc = this.includes.filter(function (include) { return include.name == tempData }, this);
                    if (inc.length) {
                        inc[0].mapped = true;
                    }else{
                        this.includes.push({ name: tempData, type: association.ToType, from: association.FromType, query: {}, options: {}, mapped: true });
                    }
                }
                else {
                    Guard.raise(new Exception("The given include path is invalid: " + expression.selector.value + ", invalid point: " + tempData));
                }
                storageModel = this.mainEntitySet.entityContext._storageModel.getStorageModel(association.ToType);
            }
        //}
    },
    VisitInlineCountExpression: function(expression, context){
        this.query.withInlineCount = true;
    }
});

/*$data.storageProviders.mongoDB.Index = function(index){
    if (typeof index === 'object'){
        for (var i in index){
            if (index.hasOwnProperty(i)){
                this[i] = index[i];
            }
        }
    }else if (typeof index === 'string'){
        this[index] = 1;
    }else throw 'Bad index configuration';
};

$data.storageProviders.mongoDB.UniqueIndex = function(index){
    if (typeof index === 'object' && Object.keys(index).length != 1)
        throw 'Bad unique index configuration';

    $data.storageProviders.mongoDB.Index.call(this, index);
};

$data.storageProviders.mongoDB.UniqueIndex.prototype = {
    getOptions: function(){
        return { unique: true };
    }
};

$data.storageProviders.mongoDB.TTLIndex = function(index){
    if (typeof index !== 'object' || typeof index[Object.keys(index)[0]] !== 'number')
        throw 'Bad TTL index configuration';

    $data.storageProviders.mongoDB.Index.call(this, index);
};

$data.storageProviders.mongoDB.TTLIndex.prototype = {
    getOptions: function(){
        return { expireAfterSeconds: this[Object.keys(this)[0]] };
    }
};*/

$C('$data.storageProviders.mongoDBPro.mongoDBProvider', $data.StorageProviderBase, null,
{
    constructor: function(cfg, ctx){
        this.driver = $data.mongoDBDriver;
        this.context = ctx;
        this.providerConfiguration = $data.typeSystem.extend({
            dbCreation: $data.storageProviders.DbCreationType.DropTableIfChanged,
            address: '127.0.0.1',
            port: 27017,
            serverOptions: {},
            databaseName: 'test'
        }, cfg);
        if (this.providerConfiguration.server){
            if (typeof this.providerConfiguration.server === 'string') this.providerConfiguration.server = [{ address: this.providerConfiguration.server.split(':')[0] || '127.0.0.1', port: this.providerConfiguration.server.split(':')[1] || 27017 }];
            if (!(this.providerConfiguration.server instanceof Array)) this.providerConfiguration.server = [this.providerConfiguration.server];
            if (this.providerConfiguration.server.length == 1){
                this.providerConfiguration.address = this.providerConfiguration.server[0].address || '127.0.0.1';
                this.providerConfiguration.port = this.providerConfiguration.server[0].port || 27017;
                delete this.providerConfiguration.server;
            }
        }
        if (this.context && this.context._buildDbType_generateConvertToFunction && this.buildDbType_generateConvertToFunction) {
            this.context._buildDbType_generateConvertToFunction = this.buildDbType_generateConvertToFunction;
        }
        if (this.context && this.context._buildDbType_modifyInstanceDefinition && this.buildDbType_modifyInstanceDefinition) {
            this.context._buildDbType_modifyInstanceDefinition = this.buildDbType_modifyInstanceDefinition;
        }
    },
    _getServer: function(){
        if (this.providerConfiguration.server){
            var replSet = [];
            for (var i = 0; i < this.providerConfiguration.server.length; i++){
                var s = this.providerConfiguration.server[i];
                replSet.push(new this.driver.Server(s.address, s.port, s.serverOptions));
            }
            
            return new this.driver.ReplSetServers(replSet);
        }else return this.driver.Server(this.providerConfiguration.address, this.providerConfiguration.port, this.providerConfiguration.serverOptions);
    },
    initializeStore: function(callBack){
        var self = this;
        callBack = $data.typeSystem.createCallbackSetting(callBack);
        
        var server = this._getServer();
        new this.driver.Db(this.providerConfiguration.databaseName, server, { safe: false }).open(function(error, client){
            if (error){
                callBack.error(error);
                return;
            }
            
            var fn = function(error, client){
                var cnt = 0;
                var collectionCount = 0;
                var readyFn = function(client, entitySet){
                    var countFn = function(){
                        if (--cnt <= 0){
                            callBack.success(self.context);
                            client.close();
                        }
                    };

                    if (entitySet){
                        var entitySetIndices = self.context._storageModel.getStorageModel(entitySet.createNew).indices;
                        if (entitySetIndices){
                            var collection = new self.driver.Collection(client, entitySet.tableName);
                            if (Array.isArray(entitySetIndices)){
                                if (entitySetIndices.length){
                                    var indices = entitySetIndices.slice();
                                    var indexFn = function(index){
                                        var keys = {};
                                        for (var i = 0; i < index.keys.length; i++){
                                            var k = index.keys[i];
                                            if (typeof k === 'string'){
                                                keys[k] = 1;
                                            }else{
                                                keys[k.field] = k.spatial ? '2d' : (typeof k.order === 'undefined' ? 1 : (typeof k.order === 'number' ? k.order : (typeof k.order === 'string' && k.order.toLowerCase() === 'desc' ? -1 : 1)));
                                            }
                                        }
                                        var options = {};
                                        if (index.unique) options.unique = index.unique;
                                        if (typeof index.expireAfterSeconds === 'number') options.expireAfterSeconds = index.expireAfterSeconds;
                                        collection.ensureIndex(keys, options, function(err, indexName){
                                            if (err){
                                                callBack.error(err);
                                                return;
                                            }
                                            
                                            entitySetIndices[entitySetIndices.indexOf(index)].name = indexName;
                                            if (indices.length) indexFn(indices.shift());
                                            else countFn();
                                        });
                                    };
                                    
                                    /*collection.dropIndexes(function(err, success){
                                        if (err){
                                            callBack.error(err);
                                            return;
                                        }*/
                                        
                                        indexFn(indices.shift());
                                    //});
                                }else countFn();
                            }else{
                                /*collection.dropIndexes(function(err, success){
                                    if (err){
                                        callBack.error(err);
                                        return;
                                    }*/
                                    var index = entitySetIndices;
                                    var keys = {};
                                    for (var i = 0; i < index.keys.length; i++){
                                        var k = index.keys[i];
                                        if (typeof k === 'string'){
                                            keys[k] = 1;
                                        }else{
                                            keys[k.field] = k.spatial ? '2d' : (typeof k.order === 'undefined' ? 1 : (typeof k.order === 'number' ? k.order : (typeof k.order === 'string' && k.order.toLowerCase() === 'desc' ? -1 : 1)));
                                        }
                                    }
                                    var options = {};
                                    if (index.unique) options.unique = index.unique;
                                    if (typeof index.expireAfterSeconds === 'number') options.expireAfterSeconds = index.expireAfterSeconds;
                                    collection.ensureIndex(keys, options, function(err, indexName){
                                        if (err){
                                            callBack.error(err);
                                            return;
                                        }
                                        
                                        index.name = indexName;
                                        countFn();
                                    });
                                //});
                            }
                        }else countFn();
                    }else countFn();
                };
                
                for (var i in self.context._entitySetReferences){
                    if (self.context._entitySetReferences.hasOwnProperty(i))
                        cnt++;
                }
                
                collectionCount = cnt;
                var sets = Object.keys(self.context._entitySetReferences);
                if (!sets.length) return readyFn(client);
                sets.forEach(function(i){
                    if (self.context._entitySetReferences.hasOwnProperty(i)){
                        client.collectionNames({ namesOnly: true }, function(error, names){
                            names = names.map(function(it){ return it.slice(it.lastIndexOf('.') + 1); });
                            switch (self.providerConfiguration.dbCreation){
                                case $data.storageProviders.DbCreationType.DropAllExistingTables:
                                    if (names.indexOf(self.context._entitySetReferences[i].tableName) >= 0){
                                        client.dropCollection(self.context._entitySetReferences[i].tableName, function(error, result){
                                            if (error){
                                                callBack.error(error);
                                                return;
                                            }
                                            if (self.context._entitySetReferences[i].tableOptions){
                                                client.createCollection(self.context._entitySetReferences[i].tableName, self.context._entitySetReferences[i].tableOptions, function(error, result){
                                                    if (error){
                                                        callBack.error(error);
                                                        return;
                                                    }
                                                    readyFn(client, self.context._entitySetReferences[i]);
                                                });
                                            }else readyFn(client, self.context._entitySetReferences[i]);
                                        });
                                    }else if (names.indexOf(self.context._entitySetReferences[i].tableName) < 0 && self.context._entitySetReferences[i].tableOptions){
                                        client.createCollection(self.context._entitySetReferences[i].tableName, self.context._entitySetReferences[i].tableOptions, function(error, result){
                                            if (error){
                                                callBack.error(error);
                                                return;
                                            }
                                            readyFn(client, self.context._entitySetReferences[i]);
                                        });
                                    }else readyFn(client, self.context._entitySetReferences[i]);
                                    break;
                                default:
                                    if (names.indexOf(self.context._entitySetReferences[i].tableName) < 0 && self.context._entitySetReferences[i].tableOptions){
                                        client.createCollection(self.context._entitySetReferences[i].tableName, self.context._entitySetReferences[i].tableOptions, function(error, result){
                                            if (error){
                                                callBack.error(error);
                                                return;
                                            }
                                            readyFn(client, self.context._entitySetReferences[i]);
                                        });
                                    }else readyFn(client, self.context._entitySetReferences[i]);
                                    break;
                            }
                        });
                    }
                });
            };
            
            if (self.providerConfiguration.username){
                client.authenticate(self.providerConfiguration.username, self.providerConfiguration.password || '', function(error, result){
                    if (error){
                        callBack.error(error);
                        return;
                    }
                    
                    if (result){
                        fn(error, client);
                        return;
                    }
                });
            }else fn(error, client);
        });
    },
    _connected: function(oid, prop, prop2, _id, association){
        var ret = false;
        //console.log('connected', oid, prop, prop2, _id, association.From, association.To);
        association.ReferentialConstraint.forEach(function(ref){
            //console.log(ref, ref[prop2], oid[ref[prop2]], _id, oid[ref[prop2]] == _id);
            //if (ref[prop2] && oid[ref[prop2]] && _id) ret = oid[ref[prop2]].toString() == _id.toString();
            if (ref[prop2] && oid[ref[prop2]] && _id) ret = JSON.stringify(oid[ref[prop2]]) == JSON.stringify(_id);
        });
        
        return ret;
    },
    /*_connected: function(oid, _id){
        //console.log(oid, _id);
        if (typeof oid == 'object'){
            for (var i in oid){
                if (oid.hasOwnProperty(i)){
                    //console.log(i, oid[i], _id[i], oid[i] == _id[i]);
                    if (!_id[i] || oid[i] != _id[i]) return false;
                }
            }
            return true;
        }else{
            return oid == _id;
        }
    },*/
    getTraceString: function (queryable) {
        return new $data.storageProviders.mongoDBPro.mongoDBCompiler().compile(queryable);
    },
    executeQuery: function(query, callBack){
        var self = this;
        callBack = $data.typeSystem.createCallbackSetting(callBack);
        
        var entitySet = query.context.getEntitySetFromElementType(query.defaultType);
        new $data.storageProviders.mongoDBPro.mongoDBCompiler().compile(query);

        var server = this._getServer();
        new this.driver.Db(this.providerConfiguration.databaseName, server, { safe: false }).open(function(error, client){
            if (error){
                callBack.error(error);
                return;
            }
            
            //console.log(query.includes);
            var collection = new self.driver.Collection(client, entitySet.tableName);
            var includes = query.includes && query.includes.length ? query.includes.map(function(it){
                //console.log(it.from.name, '=>', it.type.name, 'on', it.name);
                //console.log(it);
                //if (it.full){
                    delete it.options.fields;
                //}
                return {
                    name: it.name,
                    type: it.type,
                    from: it.from,
                    collection: new self.driver.Collection(client, query.context.getEntitySetFromElementType(it.type).tableName),
                    query: it.query || {},
                    options: it.options || {}
                };
            }) : null;
            
            query.context = self.context;
            var find = query.find;
            //console.log(JSON.stringify(find.query));

            var cb = function(error, results){
                if (error){
                    callBack.error(error);
                    return;
                }
                if (query.find.filter){
                    //console.log(results);
                    //console.log(query.find.filter.toString());
                    results = results.filter(query.find.filter);
                }

                if (query.expression.nodeType === $data.Expressions.ExpressionType.Count || query.expression.nodeType === $data.Expressions.ExpressionType.BatchDelete){
                    if (results instanceof Array){
                        query.rawDataList = [{ cnt: results.length }];
                    }else{
                        query.rawDataList = [{ cnt: results }];
                    }
                }else{
                    query.rawDataList = results;
                }
                
                //console.log(query.rawDataList);

                callBack.success(query);
                client.close();
            };
            
            var fn = function(){
                switch (query.expression.nodeType){
                    case $data.Expressions.ExpressionType.BatchDelete:
                        collection.remove(find.query, { safe: true }, cb);
                        break;
                    case $data.Expressions.ExpressionType.Count:
                        if (!includes || !includes.length){
                            collection.find(find.query, find.options).count(cb);
                            break;
                        }
                    default:
                        if (find.full){
                            delete find.options.fields;
                        }
                        var defaultFn = function(){
                            //console.log(JSON.stringify(find.query), JSON.stringify(find.options));
                            collection.find(find.query, find.options).toArray(function(error, results){
                                //console.log('collection', find.query, find.options, results);
                                if (error){
                                    callBack.error(error);
                                    return;
                                }
                                
                                var fn = function(include){
                                    //console.log(include.query, include.options);
                                    include.collection.find({}, include.options).toArray(function(error, included){
                                        //console.log('include', include.name, include.options, included);
                                        if (error){
                                            callBack.error(error);
                                            return;
                                        }
                                        
                                        var path = include.name.split('.');
                                        var prop = path[path.length - 1];
                                        var sm = self.context._storageModel.getStorageModel(include.from);
                                        
                                        var association = sm.Associations[prop];
                                        //console.log(association.FromMultiplicity, association.ToMultiplicity, association.ToPropertyName, association.FromPropertyName, include.name, prop);
                                        //console.log(results, included);
                                        
                                        for (var i = 0; i < results.length; i++){
                                            var res = results[i];
                                            //console.log(res);
                                            for (var j = 0; j < path.length - 1; j++){
                                                res = res[path[j]];
                                            }
                                            if (association.FromMultiplicity == '0..1' && association.ToMultiplicity == '*'){
                                                //console.log('0..1 -> *');
                                                var r = included.filter(function(it){
                                                    return self._connected(it, association.ToPropertyName, association.To, res._id, association);
                                                    /*if (it[association.ToPropertyName]){
                                                        //return it[association.ToPropertyName].oid.toString() == self._typeFactory('id', res._id, self.fieldConverter.fromDb);
                                                        //return it[association.ToPropertyName].oid.toString() == res._id.toString();
                                                        if (it[association.ToPropertyName] === null) return false;
                                                        return self._connected(it[association.ToPropertyName].oid, res._id);// .toString() == res._id.toString();
                                                    }else{
                                                        return null;
                                                    }*/
                                                });
                                                res[prop] = r;
                                            }else if (association.FromMultiplicity == '*' && association.ToMultiplicity == '0..1'){
                                                //console.log('* -> 0..1');
                                                var r = included.filter(function(it){
                                                    //return it._id.toString() == res[association.FromPropertyName].oid.toString();
                                                    if (res[association.FromPropertyName] === null) return false;
                                                    if (Array.isArray(res)){
                                                        for (var i = 0; i < res.length; i++){
                                                            if (self._connected(res[i], association.FromPropertyName, association.From, it._id, association)) return true;
                                                            //if (self._connected(res[i][association.FromPropertyName].oid, it._id)) return true;
                                                        }
                                                    }else return self._connected(res, association.FromPropertyName, association.From, it._id, association);
                                                    //}else return self._connected(res[association.FromPropertyName].oid, it._id);
                                                })[0];
                                                //console.log('include result', res[prop], r);
                                                res[prop] = r || res[prop];
                                            }else if (association.FromMultiplicity == '1' && association.ToMultiplicity == '0..1'){
                                                //console.log('1 -> 0..1');
                                                var r = included.filter(function(it){
                                                    return self._connected(it, association.ToPropertyName, association.To, res._id, association);
                                                    /*if (it[association.ToPropertyName]){
                                                        //return it[association.ToPropertyName].oid.toString() == self._typeFactory('id', res._id, self.fieldConverter.fromDb);
                                                        //return it[association.ToPropertyName].oid.toString() == res._id.toString();
                                                        if (it[association.ToPropertyName] === null) return false;
                                                        return self._connected(it[association.ToPropertyName].oid, res._id);
                                                    }else{
                                                        return null;
                                                    }*/
                                                })[0];
                                                res[prop] = r || res[prop];
                                            }else if (association.FromMultiplicity == '0..1' && association.ToMultiplicity == '1'){
                                                //console.log('0..1 -> 1');
                                                var r = included.filter(function(it){
                                                    return self._connected(res, association.FromPropertyName, association.From, it._id, association);
                                                    //return it._id.toString() == res[association.FromPropertyName].oid.toString();
                                                    /*if (res[association.FromPropertyName] === null) return false;
                                                    return self._connected(res[association.FromPropertyName].oid, it._id);*/
                                                })[0];
                                                res[prop] = r || res[prop];
                                            }
                                        }
                                        
                                        if (include.options.sort) {
                                            var order = Object.keys(include.options.sort);
                                            for (var i = order.length - 1; i >= 0; i--){
                                                var cmp = new Function('it', 'return it.' + order[i] + ';');
                                                if (include.options.sort[order[i]])
                                                    results.sort(function (a, b) {
                                                        var aVal = cmp(a);
                                                        var bVal = cmp(b);
                                                        return aVal === bVal ? 0 : (aVal < bVal ? 1 : -1);
                                                    });
                                                else
                                                    result.sort(function (a, b) {
                                                        var aVal = cmp(a);
                                                        var bVal = cmp(b);
                                                        return aVal === bVal ? 0 : (aVal > bVal ? 1 : -1);
                                                    });
                                            }
                                        }
                                        
                                        if (includes && includes.length){
                                            fn(includes.shift());
                                        }else{
                                            cb(error, results);
                                        }
                                    });
                                };
                                
                                if (includes && includes.length){
                                    fn(includes.shift());
                                }else{
                                    cb(error, results);
                                }
                            });
                        };
                        if (query.withInlineCount){
                            collection.find({}, {}).count(function(err, result){
                                if (error){
                                    callBack.error(error);
                                    return;
                                }
                                query.__count = result;
                                defaultFn();
                            });
                        }else defaultFn();
                        break;
                }
            };
            
            if (self.providerConfiguration.username){
                client.authenticate(self.providerConfiguration.username, self.providerConfiguration.password, function(error, result){
                    if (error){
                        callBack.error(error);
                        return;
                    }
                    
                    if (result) fn();
                    else callBack.error('Authentication failed');
                });
            }else fn();
        });
    },
    _typeFactory: function(type, value, converter){
        //console.log('typeFactory', type, value);
        if ((value && value.$ref && value.$id) || value == null || value == undefined) return value;
        var type = Container.resolveName(type);
        var converterFn = converter ? converter[type] : undefined;
        return converter && converter[type] ? converter[type](value) : new (Container.resolveType(type))(value);
    },
    _saveCollections: function(callBack, collections){
        var self = this;
        var successItems = 0;
        var server = this._getServer();
        
        var counterState = 0;
        var counterFn = function(callback){
            if (--counterState <= 0) callback();
        }
        
        var insertFn = function(client, c, collection){
            var docs = [];
            for (var i = 0; i < c.insertAll.length; i++){
                var d = c.insertAll[i];
                var props = Container.resolveType(d.type).memberDefinitions.getPublicMappedProperties();
                for (var j = 0; j < props.length; j++){
                    var p = props[j];
                    if (p.concurrencyMode === $data.ConcurrencyMode.Fixed){
                        d.data[p.name] = 0;
                    }else if (!p.computed){
                        /*if (Container.resolveType(p.type) === $data.Array && p.elementType && Container.resolveType(p.elementType) === $data.ObjectID){
                            d.data[p.name] = self._typeFactory(p.type, d.data[p.name], self.fieldConverter.toDb);
                            var arr = d.data[p.name];
                            if (arr){
                                for (var k = 0; k < arr.length; k++){
                                    arr[k] = self._typeFactory(p.elementType, arr[k], self.fieldConverter.toDb);
                                }
                            }
                        }else{*/
                            d.data[p.name] = self._typeFactory(p.type, d.data[p.name], self.fieldConverter.toDb);//self.fieldConverter.toDb[Container.resolveName(Container.resolveType(p.type))](d.data[p.name]);
                        //}
                        if (d.data[p.name] && d.data[p.name].initData) d.data[p.name] = d.data[p.name].initData;
                    }else{//} if (typeof d.data[p.name] === 'string'){
                        d.data['_id'] = self._typeFactory(p.type, d.data._id, self.fieldConverter.toDb);
                    }
                }

                docs.push(d.data);
            }
            
            //console.log(docs);
            collection.insert(docs, { safe: true }, function(error, result){
                if (error){
                    callBack.error(error);
                    client.close();
                    return;
                }
                
                for (var k = 0; k < result.length; k++){
                    var it = result[k];
                    var d = c.insertAll[k];
                    var props = Container.resolveType(d.type).memberDefinitions.getPublicMappedProperties();
                    for (var j = 0; j < props.length; j++){
                        var p = props[j];
                        //console.log(it);
                        if (!p.inverseProperty){
                            d.entity[p.name] = self._typeFactory(p.type, it[p.computed ? '_id' : p.name], self.fieldConverter.fromDb); //self.fieldConverter.fromDb[Container.resolveName(Container.resolveType(p.type))](it[p.computed ? '_id' : p.name]);
                        }
                        //d.entity[p.name] = it[p.computed ? '_id' : p.name];
                    }
                    //console.log(d.entity);
                }
                
                successItems += result.length;
                
                if (c.removeAll && c.removeAll.length){
                    removeFn(client, c, collection);
                }else{
                    if (c.updateAll && c.updateAll.length){
                        updateFn(client, c, collection);
                    }else{
                        esFn(client, successItems);
                    }
                }
            });
        };
        
        var updateFn = function(client, c, collection){
            counterState = c.updateAll.length;
            for (var i = 0; i < c.updateAll.length; i++){
                var u = c.updateAll[i];
                var where = {};
                
                var keys = Container.resolveType(u.type).memberDefinitions.getKeyProperties();
                for (var j = 0; j < keys.length; j++){
                    var k = keys[j];
                    where[k.computed ? '_id' : k.name] = self.fieldConverter.toDb[Container.resolveName(Container.resolveType(k.type))](u.entity[k.name]);
                }
                
                var set = {};
                var props = Container.resolveType(u.type).memberDefinitions.getPublicMappedProperties();
                for (var j = 0; j < props.length; j++){
                    var p = props[j];
                    if (u.entity.changedProperties.indexOf(p) >= 0){
                        if (p.concurrencyMode === $data.ConcurrencyMode.Fixed){
                            where[p.name] = self._typeFactory(p.type, u.data[p.name], self.fieldConverter.toDb);
                            if (!set.$inc) set.$inc = {};
                            set.$inc[p.name] = 1;
                        }else if (!p.computed){
                            if (typeof u.data[p.name] === 'undefined') continue;
                            if (Container.resolveType(p.type) === $data.Array && p.elementType && Container.resolveType(p.elementType) === $data.ObjectID){
                                set[p.name] = self._typeFactory(p.type, u.data[p.name], self.fieldConverter.toDb);
                                var arr = set[p.name];
                                if (arr){
                                    for (var k = 0; k < arr.length; k++){
                                        arr[k] = self._typeFactory(p.elementType, arr[k], self.fieldConverter.toDb);
                                    }
                                }
                            }else{
                                set[p.name] = self._typeFactory(p.type, u.data[p.name], self.fieldConverter.toDb); //self.fieldConverter.toDb[Container.resolveName(Container.resolveType(p.type))](u.entity[p.name]);
                            }
                        }
                    }
                }
                
                var fn = function(u){
                    collection.update(where, { $set: set }, { safe: true }, function(error, result){
                        if (error){
                            callBack.error(error);
                            client.close();
                            return;
                        }
                        
                        if (result){
                            successItems++;
                            var props = Container.resolveType(u.type).memberDefinitions.getPublicMappedProperties();
                            for (var j = 0; j < props.length; j++){
                                var p = props[j];
                                if (p.concurrencyMode === $data.ConcurrencyMode.Fixed) u.entity[p.name]++;
                            }
                            
                            counterFn(function(){
                                esFn(client, successItems);
                            });
                        }else{
                            counterState--;
                            collection.find({ _id: where._id }, {}).toArray(function(error, result){
                                if (error){
                                    callBack.error(error);
                                    return;
                                }
                                
                                var it = result[0];
                                var props = Container.resolveType(u.type).memberDefinitions.getPublicMappedProperties();
                                for (var j = 0; j < props.length; j++){
                                    var p = props[j];
                                    //if (!p.inverseProperty){
                                        u.entity[p.name] = self._typeFactory(p.type, it[p.computed ? '_id' : p.name], self.fieldConverter.fromDb);
                                    //}
                                }
                                
                                counterFn(function(){
                                    esFn(client, successItems);
                                });
                            });
                        }
                    });
                };
                
                fn(u);
            }
        };
        
        var removeFn = function(client, c, collection){
            counterState = c.removeAll.length;
            for (var i = 0; i < c.removeAll.length; i++){
                var r = c.removeAll[i];

                var keys = Container.resolveType(r.type).memberDefinitions.getKeyProperties();
                for (var j = 0; j < keys.length; j++){
                    var k = keys[j];
                    r.data[k.computed ? '_id' : k.name] = self.fieldConverter.toDb[Container.resolveName(Container.resolveType(k.type))](r.entity[k.name]);
                }
                
                var props = Container.resolveType(r.type).memberDefinitions.getPublicMappedProperties();
                for (var j = 0; j < props.length; j++){
                    var p = props[j];
                    if (!p.key) {
                        delete r.data[p.name];
                    }
                }
                
                collection.remove(r.data, { safe: true }, function(error, result){
                    if (error){
                        callBack.error(error);
                        client.close();
                        return;
                    }
                    
                    if (result) successItems++;
                    else counterState--;
                    
                    counterFn(function(){
                        if (c.updateAll && c.updateAll.length){
                            updateFn(client, c, collection);
                        }else esFn(client, successItems);
                    });
                });
            }
        };
        
        var keys = Object.keys(collections);
        var readyFn = function(client, value){
            callBack.success(value);
            client.close();
        };
        
        var esFn = function(client, value){
            if (keys.length){
                var es = keys.pop();
                if (collections.hasOwnProperty(es)){
                    var c = collections[es];
                    var collection = new self.driver.Collection(client, es);
                    if (c.insertAll && c.insertAll.length){
                        insertFn(client, c, collection);
                    }else{
                        if (c.removeAll && c.removeAll.length){
                            removeFn(client, c, collection);
                        }else{
                            if (c.updateAll && c.updateAll.length){
                                updateFn(client, c, collection);
                            }else{
                                readyFn(client, 0);
                            }
                        }
                    }
                }
            }else readyFn(client, value);
        };
        
        new this.driver.Db(this.providerConfiguration.databaseName, server, { safe: false }).open(function(error, client){
            if (error){
                callBack.error(error);
                return;
            }
            
            if (self.providerConfiguration.username){
                client.authenticate(self.providerConfiguration.username, self.providerConfiguration.password, function(error, result){
                    if (error){
                        callBack.error(error);
                        return;
                    }
                    
                    if (result) esFn(client);
                });
            }else esFn(client);
        });
    },
    saveChanges: function(callBack, changedItems){
        var self = this;
        if (changedItems.length){
            var independentBlocks = this.buildIndependentBlocks(changedItems);
            var convertedItems = [];
            var successCount = 0;
            var fn = function(block){
                var collections = {};
                for (var i = 0; i < block.length; i++) {
                    convertedItems.push(block[i].data);
                    
                    var es = collections[block[i].entitySet.name];
                    if (!es){
                        es = {};
                        collections[block[i].entitySet.name] = es;
                    }
                    
                    var initData = { entity: block[i].data, data: self.save_getInitData(block[i], convertedItems), type: Container.resolveName(block[i].data.getType()) };
                    switch (block[i].data.entityState){
                        case $data.EntityState.Unchanged: continue; break;
                        case $data.EntityState.Added:
                            if (!es.insertAll) es.insertAll = [];
                            es.insertAll.push(initData);
                            break;
                        case $data.EntityState.Modified:
                            if (!es.updateAll) es.updateAll = [];
                            es.updateAll.push(initData);
                            break;
                        case $data.EntityState.Deleted:
                            if (!es.removeAll) es.removeAll = [];
                            es.removeAll.push(initData);
                            break;
                        default: Guard.raise(new Exception("Not supported Entity state"));
                    }
                }
                //console.log('collections', collections)
                self._saveCollections({
                    success: function(cnt){
                        successCount += cnt;
                        if (independentBlocks.length){
                            fn(independentBlocks.shift());
                        }else{
                            callBack.success(successCount);
                        }
                    },
                    error: callBack.error
                }, collections);
            };
            
            if (independentBlocks.length){
                fn(independentBlocks.shift());
            }
        }else{
            callBack.success(0);
        }
    },
    buildDbType_generateConvertToFunction: function (storageModel) {
        var self = this;
        return function (logicalEntity) {
            var dbInstance = new storageModel.PhysicalType();
            dbInstance.entityState = logicalEntity.entityState;

            //logicalEntity.changedProperties.forEach(function(memberDef){
            //}, this);
            storageModel.PhysicalType.memberDefinitions.getPublicMappedProperties().forEach(function (property) {
                dbInstance.initData[property.name] = logicalEntity[property.name];
            }, this);

            if (storageModel.Associations) {
                storageModel.Associations.forEach(function (association) {
                    if ((association.FromMultiplicity == "*" && association.ToMultiplicity == "0..1") || (association.FromMultiplicity == "0..1" && association.ToMultiplicity == "1")) {
                        var complexInstance = logicalEntity[association.FromPropertyName];
                        if (complexInstance !== undefined) {
                            association.ReferentialConstraint.forEach(function (constrain) {
                                //console.log(constrain, constrain[association.From], constrain[association.To], association.From, association.To, association.FromPropertyName, association.ToPropertyName);
                                //console.log(self._entitySetReferences);
                                if (complexInstance !== null) {
                                    /*console.log(complexInstance.getType().memberDefinitions.getMember(constrain[association.To]).type, complexInstance[constrain[association.To]],
                                        self.storageProvider._typeFactory(complexInstance.getType().memberDefinitions.getMember(constrain[association.To]).type, complexInstance[constrain[association.To]], self.storageProvider.fieldConverter.toDb));*/
                                    dbInstance.initData[association.FromPropertyName] = {
                                        $ref: self._entitySetReferences[association.To].tableName,
                                        $id: self.storageProvider._typeFactory(complexInstance.getType().memberDefinitions.getMember(constrain[association.To]).type, complexInstance[constrain[association.To]], self.storageProvider.fieldConverter.toDb)
                                    };
                                    dbInstance.initData[constrain[association.From]] = self.storageProvider._typeFactory(complexInstance.getType().memberDefinitions.getMember(constrain[association.To]).type, complexInstance[constrain[association.To]], self.storageProvider.fieldConverter.toDb);
                                } else {
                                    dbInstance.initData[association.FromPropertyName] = null;
                                    dbInstance.initData[constrain[association.From]] = null;
                                }
                                //console.log(dbInstance.initData);
                            }, this);
                        }
                    }
                }, this);
            }
            if (storageModel.ComplexTypes) {
                storageModel.ComplexTypes.forEach(function (cmpType) {
                    var complexInstance = logicalEntity[cmpType.FromPropertyName];
                    dbInstance.initData[cmpType.FromPropertyName] = self.storageProvider._typeFactory(cmpType.ToType, complexInstance, self.storageProvider.fieldConverter.toDb);
                    /*if (complexInstance !== undefined && cmpType.ReferentialConstraint) {
                        cmpType.ReferentialConstraint.forEach(function (constrain) {
                            if (complexInstance !== null) {
                                dbInstance[constrain[cmpType.From]] = complexInstance[constrain[cmpType.To]];
                            } else {
                                dbInstance[constrain[cmpType.From]] = null;
                            }
                        }, this);
                    }*/
                }, this);
            }
            return dbInstance;
        };
    },
    buildDbType_modifyInstanceDefinition: function (instanceDefinition, storageModel) {
        var buildDbType_copyPropertyDefinition = function (propertyDefinition, refProp) {
            var cPropertyDef;
            if (refProp) {
                cPropertyDef = JSON.parse(JSON.stringify(instanceDefinition[refProp]));
                cPropertyDef.kind = propertyDefinition.kind;
                cPropertyDef.name = propertyDefinition.name;
                cPropertyDef.notMapped = false;
            } else {
                cPropertyDef = JSON.parse(JSON.stringify(propertyDefinition));
            }

            cPropertyDef.dataType = Container.resolveType(propertyDefinition.dataType);
            cPropertyDef.type = cPropertyDef.dataType;
            cPropertyDef.key = false;
            cPropertyDef.computed = false;
            return cPropertyDef;
        };
        var buildDbType_createConstrain = function (foreignType, dataType, propertyName, prefix) {
            var constrain = new Object();
            constrain[foreignType.name] = propertyName;
            constrain[dataType.name] = prefix + '__' + propertyName;
            return constrain;
        };

        if (storageModel.Associations) {
            storageModel.Associations.forEach(function (association) {
                var addToEntityDef = false;
                var foreignType = association.FromType;
                var dataType = association.ToType;
                var foreignPropName = association.ToPropertyName;

                association.ReferentialConstraint = association.ReferentialConstraint || [];

                if ((association.FromMultiplicity == "*" && association.ToMultiplicity == "0..1") || (association.FromMultiplicity == "0..1" && association.ToMultiplicity == "1")) {
                    foreignType = association.ToType;
                    dataType = association.FromType;
                    foreignPropName = association.FromPropertyName;
                    addToEntityDef = true;
                }

                foreignType.memberDefinitions.getPublicMappedProperties().filter(function (d) { return d.key }).forEach(function (d) {
                    if (addToEntityDef) {
                        instanceDefinition[foreignPropName + '__' + d.name] = buildDbType_copyPropertyDefinition(d, foreignPropName);
                    }
                    association.ReferentialConstraint.push(buildDbType_createConstrain(foreignType, dataType, d.name, foreignPropName));
                }, this);
            }, this);
        }
        //Copy complex type properties
        /*if (storageModel.ComplexTypes) {
            console.log('storageModel complexTypes', storageModel.ComplexTypes);
            storageModel.ComplexTypes.forEach(function (complexType) {
                complexType.ReferentialConstraint = complexType.ReferentialConstraint || [];
                console.log('complexType', complexType, 'ToType', complexType.ToType);
                if (complexType.ToType.memberDefinitions) console.log('error', complexType.ToType, complexType.FromType);
                complexType.ToType.memberDefinitions.getPublicMappedProperties().forEach(function (d) {
                    instanceDefinition[complexType.FromPropertyName + '__' + d.name] = buildDbType_copyPropertyDefinition(d);
                    complexType.ReferentialConstraint.push(buildDbType_createConstrain(complexType.ToType, complexType.FromType, d.name, complexType.FromPropertyName));
                }, this);
            }, this);
        }*/
    },
    save_getInitData: function(item, convertedItems) {
        var self = this;
        item.physicalData = this.context._storageModel.getStorageModel(item.data.getType()).PhysicalType.convertTo(item.data, convertedItems);
        //console.log(item.physicalData.initData);
        var serializableObject = {};
        item.physicalData.getType().memberDefinitions.asArray().forEach(function (memdef) {
            if (memdef.kind == $data.MemberTypes.navProperty || memdef.kind == $data.MemberTypes.complexProperty || (memdef.kind == $data.MemberTypes.property && !memdef.notMapped)) {
                /*if (Container.resolveType(memdef.type) === $data.Array && memdef.kind === $data.MemberTypes.property && item.physicalData[memdef.name]){
                    serializableObject[memdef.name] = item.physicalData[memdef.name];
                    //serializableObject[memdef.name] = JSON.parse(JSON.stringify(item.physicalData[memdef.name]));
                }else{*/
                    serializableObject[memdef.computed ? '_id' : memdef.name] = item.physicalData[memdef.name];
                //}
            }/*else if (memdef.kind == $data.MemberTypes.complexProperty){
                if (Container.resolveType(memdef.type) === $data.Array && memdef.kind === $data.MemberTypes.property && item.physicalData[memdef.name]){
                    serializableObject[memdef.name] = JSON.parse(JSON.stringify(item.physicalData[memdef.name]));
                    //serializableObject[memdef.name] = item.physicalData[memdef.name];
                }else{
                    serializableObject[memdef.computed ? '_id' : memdef.name] = item.physicalData[memdef.name];
                }
            }*/
        }, this);
        //console.log(serializableObject);
        return serializableObject;
    },
    
    supportedDataTypes: {
        value: [$data.Integer, $data.String, $data.Number, $data.Blob, $data.Boolean, $data.Date, $data.ObjectID, $data.Object, $data.GeographyPoint, $data.Guid,
            $data.GeographyLineString, $data.GeographyPolygon, $data.GeographyMultiPoint, $data.GeographyMultiLineString, $data.GeographyMultiPolygon, $data.GeographyCollection,
            $data.GeometryPoint, $data.GeometryLineString, $data.GeometryPolygon, $data.GeometryMultiPoint, $data.GeometryMultiLineString, $data.GeometryMultiPolygon, $data.GeometryCollection],
        writable: false
    },
    
    supportedBinaryOperators: {
        value: {
            equal: { mapTo: ':', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },
            notEqual: { mapTo: '$ne', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },
            equalTyped: { mapTo: ':', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },
            notEqualTyped: { mapTo: '$ne', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },
            greaterThan: { mapTo: '$gt', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },
            greaterThanOrEqual: { mapTo: '$gte', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },

            lessThan: { mapTo: '$lt', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },
            lessThenOrEqual: { mapTo: '$lte', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },
            or: { mapTo: '$or', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },
            and: { mapTo: '$and', dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression] },

            /*add: { mapTo: 'add', dataType: "number", allowedIn: [$data.Expressions.FilterExpression] },
            divide: { mapTo: 'div', allowedIn: [$data.Expressions.FilterExpression] },
            multiply: { mapTo: 'mul', allowedIn: [$data.Expressions.FilterExpression] },
            subtract: { mapTo: 'sub', allowedIn: [$data.Expressions.FilterExpression] },
            modulo: { mapTo: 'mod', allowedIn: [$data.Expressions.FilterExpression] },*/

            "in": { mapTo: "$in", allowedIn: [$data.Expressions.FilterExpression] }
        }
    },

    supportedUnaryOperators: {
        value: {
            not: { mapTo: '$nor' }
        }
    },

    supportedFieldOperations: {
        value: {
            /* string functions */

            contains: {
                dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "substring", dataType: "string" }]
            },

            startsWith: {
                dataType: "string", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "string" }, { name: "strFragment", dataType: "string" }]
            },

            endsWith: {
                dataType: "string", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "string" }, { name: "strFragment", dataType: "string" }]
            },
            
            distance: [{
                allowedType: 'GeometryPoint', mapTo: '$center',
                dataType: "number", allowedIn: $data.Expressions.FilterExpression,
                parameters: [{ name: "@expression", dataType: 'GeometryPoint' }, { name: "to", dataType: 'GeometryPoint' }],
                fixedDataType: 'decimal'
            }, {
                allowedType: 'GeographyPoint', mapTo: '$centerSphere',
                dataType: "number", allowedIn: $data.Expressions.FilterExpression,
                parameters: [{ name: "@expression", dataType: 'GeographyPoint' }, { name: "to", dataType: 'GeographyPoint' }],
                fixedDataType: 'decimal'
            }, {
                allowedType: 'GeometryPoint', mapTo: '$near',
                dataType: "number", allowedIn: $data.Expressions.OrderExpression,
                parameters: [{ name: "@expression", dataType: 'GeometryPoint' }, { name: "to", dataType: 'GeometryPoint' }],
                fixedDataType: 'decimal'
            }, {
                allowedType: 'GeographyPoint', mapTo: '$nearSphere',
                dataType: "number", allowedIn: $data.Expressions.OrderExpression,
                parameters: [{ name: "@expression", dataType: 'GeographyPoint' }, { name: "to", dataType: 'GeographyPoint' }],
                fixedDataType: 'decimal'
            }],
            
            intersects: [{
                allowedType: 'GeographyPoint', mapTo: '$polygonSphere',
                dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: 'GeographyPoint' }, { name: "in", dataType: 'GeographyPolygon' }]
            }, {
                allowedType: 'GeometryPoint', mapTo: '$polygon',
                dataType: "boolean", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: 'GeometryPoint' }, { name: "in", dataType: 'GeometryPolygon' }]
            }]
            
            /*,

            length: {
                dataType: "number", allowedIn: [$data.Expressions.FilterExpression, $data.Expressions.ProjectionExpression],
                parameters: [{ name: "@expression", dataType: "string" }]
            },

            indexOf: {
                dataType: "number", allowedIn: [$data.Expressions.FilterExpression],
                baseIndex: 1,
                parameters: [{ name: '@expression', dataType: "string" }, { name: 'strFragment', dataType: 'string' }]
            },

            replace: {
                dataType: "string", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: '@expression', dataType: "string" }, { name: 'strFrom', dataType: 'string' }, { name: 'strTo', dataType: 'string' }]
            },

            substr: {
                mapTo: "substring",
                dataType: "string", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "string" }, { name: "startFrom", dataType: "number" }, { name: "length", dataType: "number", optional: "true" }]
            },

            toLowerCase: {
                mapTo: "tolower",
                dataType: "string", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "string" }]
            },

            toUpperCase: {
                mapTo: "toupper",
                dataType: "string", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "string" }]

            },

            trim: {
                dataType: "string", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "string" }]
            },


            concat: {
                dataType: "string", allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "string" }, { name: "strFragment", dataType: "string" }]
            },*/


            /* data functions */

            /*day: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            },
            hour: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            },
            minute: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            },
            month: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            },
            second: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            },
            year: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            },*/

            /* number functions */
            /*round: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            },
            floor: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            },
            ceiling: {
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "@expression", dataType: "date" }]
            }*/
        },
        enumerable: true,
        writable: true
    },
    supportedSetOperations: {
        value: {
            filter: {},
            map: {},
            length: {},
            forEach: {},
            toArray: {},
            batchDelete: {},
            single: {},
            /*some: {
                invokable: false,
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "filter", dataType: "$data.Queryable" }],
                mapTo: 'any',
                frameType: $data.Expressions.SomeExpression
            },
            every: {
                invokable: false,
                allowedIn: [$data.Expressions.FilterExpression],
                parameters: [{ name: "filter", dataType: "$data.Queryable" }],
                mapTo: 'all',
                frameType: $data.Expressions.EveryExpression
            },*/
            take: {},
            skip: {},
            orderBy: {},
            orderByDescending: {},
            first: {},
            include: {}
        },
        enumerable: true,
        writable: true
    },
    fieldConverter: {
        value: {
            fromDb: {
                '$data.Integer': function (number) { return number; },
                '$data.Number': function (number) { return number; },
                '$data.Date': function (date) { return date ? new Date(date) : date; },
                '$data.String': function (text) { return text; },
                '$data.Boolean': function (bool) { return bool; },
                '$data.Blob': function (blob) { return blob; },
                '$data.Object': function (o) { if (o === undefined) { return new $data.Object(); } return o; },
                '$data.Array': function (o) { if (o === undefined) { return new $data.Array(); } return o; },
                '$data.ObjectID': function (id) { return id/* ? /*new Buffer(id.toString(), 'ascii').toString('base64')id.toString() : id*/; },
                '$data.GeographyPoint': function (g) { if (g) { return new $data.GeographyPoint(g); } return g; },
                '$data.GeographyLineString': function (g) { if (g) { return new $data.GeographyLineString(g); } return g; },
                '$data.GeographyPolygon': function (g) { if (g) { return new $data.GeographyPolygon(g); } return g; },
                '$data.GeographyMultiPoint': function (g) { if (g) { return new $data.GeographyMultiPoint(g); } return g; },
                '$data.GeographyMultiLineString': function (g) { if (g) { return new $data.GeographyMultiLineString(g); } return g; },
                '$data.GeographyMultiPolygon': function (g) { if (g) { return new $data.GeographyMultiPolygon(g); } return g; },
                '$data.GeographyCollection': function (g) { if (g) { return new $data.GeographyCollection(g); } return g; },
                '$data.GeometryPoint': function (g) { if (g) { return new $data.GeometryPoint(g); } return g; },
                '$data.GeometryLineString': function (g) { if (g) { return new $data.GeometryLineString(g); } return g; },
                '$data.GeometryPolygon': function (g) { if (g) { return new $data.GeometryPolygon(g); } return g; },
                '$data.GeometryMultiPoint': function (g) { if (g) { return new $data.GeometryMultiPoint(g); } return g; },
                '$data.GeometryMultiLineString': function (g) { if (g) { return new $data.GeometryMultiLineString(g); } return g; },
                '$data.GeometryMultiPolygon': function (g) { if (g) { return new $data.GeometryMultiPolygon(g); } return g; },
                '$data.GeometryCollection': function (g) { if (g) { return new $data.GeometryCollection(g); } return g; },
                "$data.Guid": function (g) { return g ? $data.parseGuid(g).toString() : g; }
            },
            toDb: {
                '$data.Integer': function (number) { return number; },
                '$data.Number': function (number) { return number; },
                '$data.Date': function (date) { return date; },
                '$data.String': function (text) { return text; },
                '$data.Boolean': function (bool) {
                    if (typeof bool === 'string') {
                        switch (bool) {
                            case 'true': case 'true': case 'TRUE':
                            case 'yes': case 'Yes': case 'YES':
                                return true;
                            default:
                                return false;
                        }
                    }
                    //return typeof bool === 'string' ? (bool === 'true' ? true : false) : !!bool;
                    return bool === null || bool === undefined ? null : !!bool;
                },
                '$data.Blob': function (blob) { return blob; },
                '$data.Object': function (o) { return o; },
                '$data.Array': function (o) { return o; },
                '$data.ObjectID': function (id) {
                    /*var r = $data.Container.convertTo(id, $data.ObjectID);
                    //console.log('toDb', id, r, typeof id, typeof r);
                    return r;*/
                    if (id && typeof id === 'string'){
                        try{
                            return new $data.ObjectID(id);
                        }catch(e){
                            try{
                                return new $data.ObjectID(new Buffer(id, 'base64').toString('ascii'));
                            }catch(e){
                                console.log(e);
                                return id;
                            }
                        }
                    }else return id;
                },
                '$data.GeographyPoint': function (g) { return g.coordinates; },
                '$data.GeographyLineString': function (g) { return g; },
                '$data.GeographyPolygon': function (g) { return g; },
                '$data.GeographyMultiPoint': function (g) { return g; },
                '$data.GeographyMultiLineString': function (g) { return g; },
                '$data.GeographyMultiPolygon': function (g) { return g; },
                '$data.GeographyCollection': function (g) { return g; },
                '$data.GeometryPoint': function (g) { return g.coordinates; },
                '$data.GeometryLineString': function (g) { return g; },
                '$data.GeometryPolygon': function (g) { return g; },
                '$data.GeometryMultiPoint': function (g) { return g; },
                '$data.GeometryMultiLineString': function (g) { return g; },
                '$data.GeometryMultiPolygon': function (g) { return g; },
                '$data.GeometryCollection': function (g) { return g; },
                "$data.Guid": function (g) { return g ? g.toString() : g; }
            }
        }
    }
}, {
    isSupported: {
        get: function(){
            if (!$data.mongoDBDriver) return false;
            return true;
        },
        set: function(value){}
    }
});

if ($data.storageProviders.mongoDBPro.mongoDBProvider.isSupported){
    $data.StorageProviderBase.registerProvider('mongoDB', $data.storageProviders.mongoDBPro.mongoDBProvider);
}
